şu an nasıl çözeceğimizi anlayamadım ben sana execution ile alakalı tüm kodları atayım sne çöz: exec.c: #include "../minishell.h"

char	*find_path(char *cmd)
{
	char	**paths;
	char	*tmp;
	char	*candidate;
	char	*full_path;
	int		i;

	i = 0;
	tmp = ft_path(); // PATH environment değişkeni
	if (!tmp)
		return (NULL);
	paths = ft_split(tmp, ':');
	free(tmp);
	while (paths[i])
	{
		candidate = ft_strjoin(paths[i], "/");
		full_path = ft_strjoin(candidate, cmd);
		free(candidate);
		if (access(full_path, X_OK) == 0)
			return (full_path);
		free(full_path);
		i++;
	}
	return (NULL);
}

static void	handle_redirections(t_redirect *redir)
{
	t_redirect	*tmp;
	int			fd;

	tmp = redir;
	handle_heredocs(tmp); // sadece heredoc'ları burada işliyoruz
	while (redir)
	{
		fd = -1;
		if (redir->type == 1)
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (redir->type == 2)
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
		else if (redir->type == 3)
			fd = open(redir->filename, O_RDONLY);
		if (redir->type != 4 && fd == -1)
		{
			perror("redir"); // hatakodu(56);
			exit(1);         // HATAA DURUMUUU//error(56);
		}
		if (redir->type == 3)
			dup2(fd, STDIN_FILENO);
		else if (redir->type == 1 || redir->type == 2)
			dup2(fd, STDOUT_FILENO);
		if (fd != -1)
			close(fd);
		redir = redir->next;
	}
}

static char	**convert_env_to_array(t_env *env, int count, int i)
{
	t_env	*tmp;
	char	**env_array;
	char	*joined;

	tmp = env;
	while (tmp)
	{
		count++;
		tmp = tmp->next;
	}
	env_array = malloc(sizeof(char *) * (count + 1)); // +1 NULL için
	if (!env_array)
		return (NULL);
	tmp = env;
	while (tmp)
	{
		joined = ft_strjoin(tmp->key, "=");              // "KEY="
		env_array[i++] = ft_strjoin(joined, tmp->value); // "KEY=VALUE"
		free(joined);                                    // silinecek
		tmp = tmp->next;
	}
	env_array[i] = NULL; // NULL sonlandır
	return (env_array);
}
static void	exec_child(t_command *cmd, int prev_fd, int pipe_fd[2],
		t_env **env_list)
{
	char	*path;

	if (cmd->redir)
		handle_redirections(cmd->redir);
	if (prev_fd != -1)
	{
		dup2(prev_fd, STDIN_FILENO);
		close(prev_fd);
	}
	if (cmd->next)
	{
		dup2(pipe_fd[1], STDOUT_FILENO);
		close(pipe_fd[0]);
		close(pipe_fd[1]);
	}
	// ✅ 1. Builtin ise exit ile dön
	if (built_in(cmd, env_list) == 0)
		exit(0);
	// ✅ 2. Execve için PATH çöz
	path = NULL;
	if (ft_strchr(cmd->av[0], '/'))
	{
		struct stat st; // tyeni eklendi dosya bilgilerini alıyormuş detaylı bak
		if (access(cmd->av[0], F_OK) != 0)
			error(0, cmd->av[0], ": No such file or directory\n", 127);
		else if (access(cmd->av[0], X_OK) != 0)
			error(0, cmd->av[0], ": Permission denied\n", 126);
		else if (stat(cmd->av[0], &st) == 0 && S_ISDIR(st.st_mode))
			error(0, cmd->av[0], ": Is a directory\n", 126);
		else
			path = ft_strdup(cmd->av[0]);
	}
	else
	{
		path = find_path(cmd->av[0]);
		if (!path)
			error(0, cmd->av[0], ": command not found\n", 127);
	}
	// ✅ 3. Execve çağır
	execve(path, cmd->av, convert_env_to_array(*env_list, 0, 0));
	perror("execve");
	exit(126);
}

int	exec(t_command *cmd, t_env **env_list)
{
	int		prev_fd;
	int		pipe_fd[2];
	pid_t	pid;
	int		status;
	int		last_exit;

	prev_fd = -1;
	g_signal = 1;
	if (!cmd->av || !cmd->av[0])
		return (0);
	if (!cmd->next && is_parent_builtin(cmd))
		return (built_in(cmd, env_list));
	while (cmd)
	{
		if (cmd->next && pipe(pipe_fd) == -1)
		{
			perror("pipe"); // ERORR GELCEK
			exit(1);        // ERORR GELCEK
		}
		pid = fork();
		if (pid == -1)
		{
			perror("fork"); // ERORR GELCEK
			exit(1);        // ERORR GELCEK
		}
		if (pid == 0)
			exec_child(cmd, prev_fd, pipe_fd, env_list);
		if (prev_fd != -1)
			close(prev_fd);
		if (cmd->next)
		{
			close(pipe_fd[1]);
			prev_fd = pipe_fd[0];
		}
		else
			prev_fd = -1;
		cmd = cmd->next;
	}
	last_exit = 0;
	while (wait(&status) > 0)
	{
		if (WIFEXITED(status))
			last_exit = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			last_exit = 128 + WTERMSIG(status);
	}
	return (last_exit);
}, exec_utils.c: #include "../minishell.h"

int	error_value(int num)
{
	return (num); // :D
}

char	*ft_path(void)
{
	char	*path_env;

	path_env = getenv("PATH");
	if (!path_env)
		exit(1); // ERORR GELCEK
	return (strdup(path_env));
}

void	handle_heredocs(t_redirect *redir)
{
	int		fd[2];
	int		heredoc_fd;
	char	*line;

	heredoc_fd = -1;
	g_signal = 2;
	while (redir)
	{
		if (redir->type == 4)
		{
			if (pipe(fd) == -1)
			{
				perror("pipe");
				exit(1);
			}
			while (1)
			{
				line = readline("> ");
				if (!line || (!ft_strncmp(line, redir->filename,
							ft_strlen(redir->filename))
						&& line[ft_strlen(redir->filename)] == '\0'))
					break ;
				write(fd[1], line, ft_strlen(line));
				write(fd[1], "\n", 1);
				free(line);
			}
			free(line);
			close(fd[1]);
			if (heredoc_fd != -1)
				close(heredoc_fd);
			heredoc_fd = fd[0]; // sadece son heredoc'un pipe'ı tutulur
		}
		redir = redir->next;
	}
	if (heredoc_fd != -1)
		dup2(heredoc_fd, STDIN_FILENO);
}

int	is_numeric(const char *str)
{
	int i = 0;

	if (!str)
		return (0);
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}, built_in.c: # include "../../minishell.h"

int built_in(t_command *cmd, t_env **env_list)
{
	if(!ft_strncmp(cmd->av[0], "echo", 4) && cmd->av[0][4] == '\0')
		return (echo_cmd(cmd->av));
	else if(!ft_strncmp(cmd->av[0], "cd", 2) && cmd->av[0][2] == '\0') 
		return (cd_cmd(cmd));
	else if(!ft_strncmp(cmd->av[0], "pwd", 3) && cmd->av[0][3] == '\0')
		return (pwd_cmd());
	else if(!ft_strncmp(cmd->av[0], "export", 6) && cmd->av[0][6] == '\0')
		return (export_cmd(cmd->av, env_list));
	else if(!ft_strncmp(cmd->av[0], "unset", 5) && cmd->av[0][5] == '\0')
		return (unset_cmd(cmd, env_list));
	else if(!ft_strncmp(cmd->av[0], "env", 3) && cmd->av[0][3] == '\0') 
		return (env_cmd(*env_list));
	else if (!ft_strncmp(cmd->av[0], "exit", 4) && cmd->av[0][4] == '\0')
		return (exit_cmd(cmd->av));
	else
		return 1;//komut yok 
}
int echo_cmd(char **str)
{
	int i;
	
	i = 0;
	if (!ft_strncmp(str[1], "-n", ft_strlen(str[1])) && !(i++))//25 satır -n için -->!(i++)
	{
		while (str[++i])
		{
			if (!str[i + 1])
				printf("%s", str[i]);
			else
				printf("%s ", str[i]);
		}
	}
	else
	{
		while (str[++i])
		{
			if (!str[i + 1])
				printf("%s", str[i]);
			else
				printf("%s ", str[i]);
		}
		printf("\n");
	}
	return 0;

}
int env_cmd(t_env *env)
{
	while (env)
	{
		if (env->value != NULL)
			printf("%s=%s\n", env->key, env->value);
		env = env->next;
	}
	return 0;
}


int pwd_cmd()
{
	char cwd[1024];
    if(!getcwd(cwd, sizeof(cwd)))
	{
		perror("pwd");//hata DURUMUUUUU
		return 1;
	}	
	printf("%s\n", cwd);
	return 0;
}

int	exit_cmd(char **av)
{
	int code;

	printf("exit\n");
	if (!av[1])
		exit(0);
	if (!is_numeric(av[1]))
		error("minishell: exit: `", 0, ERR_EXIT, 2);
	if (av[2])
		error("minishell: exit: `", 0, ERR_2_ARG, 1);
	code = ft_atoi(av[1]) % 256;
	if (code < 0)
		code += 256;
	exit(code);
}
, built_in_utils.c: #include "../../minishell.h"

// BURAYA ANA PROCESSDE ÇALIŞACAK BUİLT_İN FONKSİYONLARI GELECEK

int	is_parent_builtin(t_command *cmd)
{
	if (!cmd || !cmd->av || !cmd->av[0])
		return (0);
	if ((!ft_strncmp(cmd->av[0], "cd", 2) && cmd->av[0][2] == '\0')
		|| (!ft_strncmp(cmd->av[0], "exit", 4) && cmd->av[0][4] == '\0')
		|| (!ft_strncmp(cmd->av[0], "export", 6) && cmd->av[0][6] == '\0')
		|| (!ft_strncmp(cmd->av[0], "unset", 5) && cmd->av[0][5] == '\0'))
		return (1);
	return (0);
}
int	cd_cmd(t_command *cmd)
{
	char	*path;

	if (!cmd->av[1] || !cmd->av[1][0])
	{
		path = getenv("HOME");
		if (!path)
			error("minishell: cd: `", cmd->av[1], ERR_CD, 2);
	}
	else if (cmd->av[2])
		error("minishell: cd: `", cmd->av[1], ERR_2_ARG, 1);
	else
		path = cmd->av[1];
	if (chdir(path))
		error("minishell: cd: `", 0, ERR_CD, 1);
	return (0);
}
//* Yeni eklendi export hata durumu için
int	is_valid_identifier(char *str)
{
	int	i;

	i = 0;
	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	while (str[i] && str[i] != '=')
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}
//*

// int	export_cmd(char **av, t_env **env)
// {
// 	int		i;
// 	char	*value;

// 	i = 1;
// 	if (!av[i])
// 	{
// 		print_export(*env);
// 		return (0);
// 	}
// 	while (av[i])
// 	{
// 		value = ft_strchr(av[i], '=');
// 		if (value)
// 			add_or_update_env(env, value, av[i]); // **env → env**
// 		else
// 			export_key_only(env, av[i]);
// 		i++;
// 	}
// 	return (0);
// }

int	export_cmd(char **av, t_env **env)
{
	int		i;
	char	*value;

	i = 1;
	if (!av[i])
	{
		print_export(*env);
		return (0);
	}
	while (av[i])
	{
		if (!is_valid_identifier(av[i]))
			error("minishell: export: `", av[i], ERR_EXP, 1);
		value = ft_strchr(av[i], '=');
		if (value)
			add_or_update_env(env, value, av[i]);
		else
			export_key_only(env, av[i]);
		i++;
	}
	return (0);
}

int	unset_cmd(t_command *cmd, t_env **env_list)
{
	int	i;

	i = 1;
	while (cmd->av[i])
	{
		unset_var(env_list, cmd->av[i]); // global env list'ten sil
		i++;
	}
	return (0);
}
void	print_export(t_env *env)
{
	while (env)
	{
		if (env->value)
			printf("declare -x %s=\"%s\"\n", env->key, env->value);
		else if (env->value == NULL)
			printf("declare -x %s\n", env->key);
		env = env->next;
	}
}, env_fonc.c: # include "../../minishell.h"

t_env *init_env(char **env, int i)
{
	t_env *env_list;
	char *eq;
	int key_len;
	char *key;
	char *val;
	i = 0;
	env_list = NULL;
	while (env[i])
	{
		eq = ft_strchr(env[i], '=');
		if (!eq)
		{
			i++;
			continue;
		}
		key_len = eq - env[i];
		key = ft_substr(env[i], 0, key_len);
		val = ft_strdup(eq + 1);
		insert_sorted_env(&env_list, key, val);
		free(key);
		free(val);
		i++;
	}
	return env_list;
}
t_env *find_env(t_env *env, const char *key)
{
	while (env)
	{
		// Tam eşleşme kontrolü
		if (!ft_strncmp(env->key, key,ft_strlen(env->key)))
			return env;
		env = env->next;
	}
	return NULL;
}
void update_env(t_env *node, const char *value)
{
	if (!node)
		return;
	free(node->value);               // Önce eski değeri temizle
	node->value = ft_strdup(value);  // Yeni değeri kopyala
}
void append_env(t_env *env, const char *key, const char *value)
{
	t_env *new;
	t_env *tail;
	// Yeni node oluştur
	new = malloc(sizeof(t_env));
	new->key = ft_strdup(key);
	new->value = ft_strdup(value);
	new->next = NULL;

	//printf("%s = %s", new->key, new->value);
	if (!env)
		env = new; // Liste boşsa bu ilk eleman olur
	else
	{
		tail = env;
		// Listenin sonuna git
		while (tail->next)
			tail = tail->next;
		tail->next = new; // Yeni elemanı sona ekle
	}
}
void add_or_update_env(t_env **env, char *eq, char *av)
{
	int key_len = eq - av;
	char *key = ft_substr(av, 0, key_len);
	char *val = ft_strdup(eq + 1);

	insert_sorted_env(env, key, val);

	free(key);
	free(val);
}

, env_fonc_utils.c: # include "../../minishell.h"
int ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
	}
	return ((unsigned char)*s1 - (unsigned char)*s2);
}

void insert_sorted_env(t_env **env, char *key, char *value)
{
	t_env *curr = *env;
	t_env *prev = NULL;

	
	while (curr && ft_strcmp(curr->key, key) < 0)
	{
		prev = curr;
		curr = curr->next;
	}

	if (curr && ft_strcmp(curr->key, key) == 0)
	{
		// Aynı key varsa, değeri güncelle
		update_env(curr, value);
		return;
	}

	// Yeni düğüm oluştur
	t_env *new = malloc(sizeof(t_env));
	if (!new)
		return;
	new->key = ft_strdup(key);
	new->value = value ? ft_strdup(value) : NULL;
	new->next = curr;

	if (prev)
		prev->next = new;
	else
		*env = new;
}
void export_key_only(t_env **env, const char *key)
{
	if (find_env(*env, key))
		return;

	insert_sorted_env(env, (char *)key, NULL);
}
void unset_var(t_env **env, const char *key)
{
	t_env *curr = *env;
	t_env *prev = NULL;

	while (curr)
	{
		if (!ft_strncmp(curr->key, key, ft_strlen(key)) && curr->key[ft_strlen(key)] == '\0')
		{
			if (prev) // ortadaysa ya da sondaysa
				prev->next = curr->next;
			else      // head ise
				*env = curr->next;

			free(curr->key);
			free(curr->value);
			free(curr);
			return;
		}
		prev = curr;
		curr = curr->next;
	}
}

, bu kadar sorun nereden tam olarak hangi dosya içinde hangi kısmı düzeltmem gerekiyor